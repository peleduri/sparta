name: Sparta - Multi-Organization Vulnerability Scan

on:
  workflow_dispatch:
    inputs:
      github-orgs:
        description: 'Comma-separated list of GitHub organizations to scan'
        required: true
        type: string
      batch-size:
        description: 'Number of repositories per batch (default: 100)'
        required: false
        type: string
        default: '100'
  schedule:
    # Run daily at 3 AM UTC (after single-org scan at 2 AM)
    - cron: '0 3 * * *'

env:
  BATCH_SIZE: ${{ inputs.batch-size || '100' }}
  MAX_RETRIES: '3'

jobs:
  get-repos:
    name: Get All Organization Repositories
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: read
    outputs:
      total-repos: ${{ steps.get-repos.outputs.count }}
      total-orgs: ${{ steps.get-repos.outputs.orgs }}
      needs-batching: ${{ steps.detect-batching.outputs.needs_batching }}
      matrix: ${{ steps.batch-repos.outputs.matrix }}
      total-batches: ${{ steps.batch-repos.outputs.total_batches }}
      token-map: ${{ steps.generate-org-tokens.outputs.token_map }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Parse organizations
        id: parse-orgs
        run: |
          ORGS="${{ inputs.github-orgs || github.event.inputs.github-orgs || github.repository_owner }}"
          echo "orgs=$ORGS" >> $GITHUB_OUTPUT
          # Create JSON array for matrix strategy
          IFS=',' read -ra ORG_ARRAY <<< "$ORGS"
          ORG_JSON="["
          for i in "${!ORG_ARRAY[@]}"; do
            if [ $i -gt 0 ]; then
              ORG_JSON+=","
            fi
            ORG_JSON+="{\"org\":\"${ORG_ARRAY[i]// /}\"}"
          done
          ORG_JSON+="]"
          echo "orgs_json=$ORG_JSON" >> $GITHUB_OUTPUT

      - name: Generate GitHub App token (default for repository owner)
        id: generate-base-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.SPARTA_APP_ID }}
          private-key: ${{ secrets.SPARTA_APP_PRIVATE_KEY }}
          owner: ${{ github.repository_owner }}

      - name: Mask base token
        run: |
          echo "::add-mask::${{ steps.generate-base-token.outputs.token }}"
          echo "GITHUB_APP_TOKEN=${{ steps.generate-base-token.outputs.token }}" >> $GITHUB_ENV

      - name: Install Python dependencies for token generation
        run: |
          pip install --quiet PyJWT cryptography requests

      - name: Generate per-org tokens using GitHub API
        id: generate-org-tokens
        env:
          ORGS: ${{ steps.parse-orgs.outputs.orgs }}
          APP_ID: ${{ secrets.SPARTA_APP_ID }}
          APP_PRIVATE_KEY: ${{ secrets.SPARTA_APP_PRIVATE_KEY }}
        run: |
          python3 << 'EOF'
          import json
          import os
          import time
          import jwt
          import requests
          from datetime import datetime, timedelta
          
          def generate_jwt(app_id, private_key):
              """Generate JWT for GitHub App authentication."""
              now = datetime.utcnow()
              payload = {
                  'iat': now - timedelta(seconds=60),
                  'exp': now + timedelta(minutes=10),
                  'iss': app_id
              }
              return jwt.encode(payload, private_key, algorithm='RS256')
          
          def get_installation_token(jwt_token, org_name):
              """Get installation access token for an organization."""
              # First, find the installation ID for this org
              headers = {
                  'Authorization': f'Bearer {jwt_token}',
                  'Accept': 'application/vnd.github.v3+json'
              }
              
              # Try to get installation for this org
              response = requests.get(
                  f'https://api.github.com/orgs/{org_name}/installation',
                  headers=headers,
                  timeout=10
              )
              
              if response.status_code == 404:
                  return None, f"GitHub App not installed on {org_name}"
              elif response.status_code != 200:
                  return None, f"Error checking installation: {response.status_code}"
              
              installation_id = response.json()['id']
              
              # Generate installation access token
              response = requests.post(
                  f'https://api.github.com/app/installations/{installation_id}/access_tokens',
                  headers=headers,
                  timeout=10
              )
              
              if response.status_code != 201:
                  return None, f"Error generating token: {response.status_code}"
              
              return response.json()['token'], None
          
          orgs_str = os.environ.get('ORGS', '')
          app_id = os.environ.get('APP_ID', '')
          private_key = os.environ.get('APP_PRIVATE_KEY', '')
          
          if not orgs_str or not app_id or not private_key:
              print("Error: Missing required environment variables")
              exit(1)
          
          orgs = [org.strip() for org in orgs_str.split(',') if org.strip()]
          token_map = {}
          failed_orgs = []
          
          # Generate JWT once
          try:
              jwt_token = generate_jwt(app_id, private_key)
          except Exception as e:
              print(f"Error generating JWT: {e}")
              exit(1)
          
          # Generate token for each org
          for org in orgs:
              try:
                  token, error = get_installation_token(jwt_token, org)
                  if token:
                      token_map[org] = token
                      print(f"✓ Token generated for {org}")
                      # Mask the token
                      print(f"::add-mask::{token}")
                  else:
                      print(f"⚠ Warning: {error}")
                      failed_orgs.append(org)
              except Exception as e:
                  print(f"⚠ Warning: Failed to generate token for {org}: {e}")
                  failed_orgs.append(org)
          
          # If no tokens generated, use base token as fallback
          if not token_map:
              print("Warning: No org-specific tokens generated, using base token for all orgs")
              base_token = os.environ.get('BASE_TOKEN', '')
              if base_token:
                  for org in orgs:
                      token_map[org] = base_token
          
          # Save token map as JSON
          token_map_json = json.dumps(token_map)
          github_output = os.environ.get('GITHUB_OUTPUT', '/dev/stdout')
          with open(github_output, 'a') as f:
              f.write(f"token_map={token_map_json}\n")
              f.write(f"failed_orgs={json.dumps(failed_orgs)}\n")
          
          if failed_orgs:
              print(f"\n⚠ Warning: Failed to generate tokens for: {', '.join(failed_orgs)}")
              print("  Make sure the GitHub App is installed on these organizations")
          EOF
        env:
          BASE_TOKEN: ${{ steps.generate-base-token.outputs.token }}

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Get all organization repositories
        id: get-repos
        env:
          GITHUB_ORGS: ${{ steps.parse-orgs.outputs.orgs }}
          GITHUB_APP_TOKEN_MAP: ${{ steps.generate-org-tokens.outputs.token_map }}
          GITHUB_APP_TOKEN: ${{ env.GITHUB_APP_TOKEN }}
        run: |
          docker run --rm \
            --user $(id -u):$(id -g) \
            -v "${{ github.workspace }}":/workspace \
            -v "${{ github.output }}":/github_output \
            -w /workspace \
            -e GITHUB_ORGS \
            -e GITHUB_APP_TOKEN_MAP \
            -e GITHUB_APP_TOKEN \
            -e GITHUB_OUTPUT=/github_output \
            ghcr.io/${{ github.repository_owner }}/sparta:latest \
            get-repos
        continue-on-error: false

      - name: Auto-detect large orgs and enable batching
        id: detect-batching
        run: |
          python3 << 'EOF'
          import json
          import os
          
          with open('repos.json', 'r') as f:
              repos_data = json.load(f)
          
          # Check if multi-org format
          is_multi_org = (
              isinstance(repos_data, list) and 
              len(repos_data) > 0 and 
              isinstance(repos_data[0], dict) and 
              'org' in repos_data[0] and 
              'repos' in repos_data[0]
          )
          
          if is_multi_org:
              large_orgs = []
              for org_data in repos_data:
                  if len(org_data.get('repos', [])) > 500:
                      large_orgs.append(org_data['org'])
              needs_batching = len(large_orgs) > 0
              github_output = os.environ.get('GITHUB_OUTPUT', '/dev/stdout')
              with open(github_output, 'a') as f:
                  f.write(f"needs_batching={'true' if needs_batching else 'false'}\n")
                  f.write(f"large_orgs={','.join(large_orgs)}\n")
          else:
              # Single org format
              repos = repos_data if isinstance(repos_data, list) else []
              needs_batching = len(repos) > 500
              github_output = os.environ.get('GITHUB_OUTPUT', '/dev/stdout')
              with open(github_output, 'a') as f:
                  f.write(f"needs_batching={'true' if needs_batching else 'false'}\n")
          EOF

      - name: Split repositories into batches
        id: batch-repos
        if: steps.detect-batching.outputs.needs_batching == 'true'
        env:
          BATCH_SIZE: ${{ env.BATCH_SIZE }}
        run: |
          docker run --rm \
            --user $(id -u):$(id -g) \
            -v "${{ github.workspace }}":/workspace \
            -v "${{ github.output }}":/github_output \
            -w /workspace \
            -e BATCH_SIZE \
            -e GITHUB_OUTPUT=/github_output \
            ghcr.io/${{ github.repository_owner }}/sparta:latest \
            batch-repos
      
      - name: Set default batch outputs
        if: steps.detect-batching.outputs.needs_batching != 'true'
        run: |
          github_output="${{ github.output }}"
          echo "matrix=[]" >> "$github_output"
          echo "total_batches=0" >> "$github_output"

      - name: Upload repos and batches
        uses: actions/upload-artifact@v4
        with:
          name: repos-and-batches
          path: |
            repos.json
            repo-batches.json
            scan-state-*.json
          retention-days: 1
          if-no-files-found: ignore

  scan-batches:
    name: Scan Batch ${{ matrix.batch_id }}
    needs: [get-repos]
    runs-on: ubuntu-latest
    if: needs.get-repos.outputs.needs-batching == 'true' && needs.get-repos.outputs.total-batches != '' && needs.get-repos.outputs.total-batches > 0
    strategy:
      fail-fast: false
      matrix:
        include: ${{ fromJson(needs.get-repos.outputs.matrix) }}
    permissions:
      contents: read
      packages: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Generate GitHub App token
        id: generate-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.SPARTA_APP_ID }}
          private-key: ${{ secrets.SPARTA_APP_PRIVATE_KEY }}
          owner: ${{ github.repository_owner }}

      - name: Mask token and set environment
        id: mask-token
        env:
          GENERATED_TOKEN: ${{ steps.generate-token.outputs.token }}
        run: |
          if [ -z "$GENERATED_TOKEN" ]; then
            echo "GitHub App token generation failed" >&2
            exit 1
          fi
          echo "::add-mask::$GENERATED_TOKEN"
          echo "GITHUB_APP_TOKEN=$GENERATED_TOKEN" >> $GITHUB_ENV

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Download repos and batches
        uses: actions/download-artifact@v4
        with:
          name: repos-and-batches
          path: .

      - name: Extract batch repositories
        id: extract-batch
        env:
          BATCH_ID: ${{ matrix.batch_id }}
        run: |
          python3 << 'EOF'
          import json
          import os
          from datetime import datetime
          
          batch_id = os.environ.get('BATCH_ID')
          if not batch_id:
              print("Error: BATCH_ID environment variable not set")
              exit(1)
          
          with open('repo-batches.json', 'r') as f:
              batches = json.load(f)
          
          batch = next((b for b in batches if b['batch_id'] == batch_id), None)
          if not batch:
              print(f"Error: Batch {batch_id} not found")
              exit(1)
          
          # Determine org name
          org_name = batch.get('org', 'unknown')
          
          # Create repos.json in single-org format for this batch
          # (scan_repos.py will handle it correctly)
          with open('repos.json', 'w') as f:
              json.dump(batch['repos'], f, indent=2)
          
          # Set GITHUB_ORG for single-org mode
          os.environ['GITHUB_ORG'] = org_name
          
          print(f"Batch {batch_id} contains {len(batch['repos'])} repositories")
          print(f"Organization: {org_name}")
          
          # Set outputs
          github_output = os.environ.get('GITHUB_OUTPUT', '/dev/stdout')
          with open(github_output, 'a') as f:
              f.write(f"org={org_name}\n")
              f.write(f"repo_count={len(batch['repos'])}\n")
          EOF
          echo "BATCH_ID=${{ matrix.batch_id }}" >> $GITHUB_ENV
          echo "GITHUB_ORG=${{ steps.extract-batch.outputs.org }}" >> $GITHUB_ENV

      - name: Scan batch repositories
        env:
          GITHUB_ORG: ${{ steps.extract-batch.outputs.org }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_APP_TOKEN: ${{ env.GITHUB_APP_TOKEN }}
          GITHUB_APP_TOKEN_MAP: ${{ needs.get-repos.outputs.token-map }}
          GITHUB_WORKSPACE: ${{ github.workspace }}
          BATCH_SIZE: ${{ env.BATCH_SIZE }}
          MAX_RETRIES: ${{ env.MAX_RETRIES }}
        run: |
          docker run --rm \
            --user $(id -u):$(id -g) \
            -v "${{ github.workspace }}":/workspace \
            -w /workspace \
            -e GITHUB_ORG \
            -e GITHUB_REPOSITORY \
            -e GITHUB_APP_TOKEN \
            -e GITHUB_APP_TOKEN_MAP \
            -e GITHUB_WORKSPACE=/workspace \
            -e BATCH_SIZE \
            -e MAX_RETRIES \
            ghcr.io/${{ github.repository_owner }}/sparta:latest \
            scan-repos

      - name: Upload batch scan results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: scan-results-${{ matrix.batch_id }}
          path: |
            vulnerability-reports/
            scan-state-*.json
          retention-days: 7
          if-no-files-found: ignore

  scan-no-batch:
    name: Scan All Repositories (No Batching)
    needs: [get-repos]
    runs-on: ubuntu-latest
    if: needs.get-repos.outputs.needs-batching != 'true'
    permissions:
      contents: read
      packages: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Generate GitHub App token
        id: generate-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.SPARTA_APP_ID }}
          private-key: ${{ secrets.SPARTA_APP_PRIVATE_KEY }}
          owner: ${{ github.repository_owner }}

      - name: Mask token and set environment
        id: mask-token
        env:
          GENERATED_TOKEN: ${{ steps.generate-token.outputs.token }}
        run: |
          if [ -z "$GENERATED_TOKEN" ]; then
            echo "GitHub App token generation failed" >&2
            exit 1
          fi
          echo "::add-mask::$GENERATED_TOKEN"
          echo "GITHUB_APP_TOKEN=$GENERATED_TOKEN" >> $GITHUB_ENV

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Download repos
        uses: actions/download-artifact@v4
        with:
          name: repos-and-batches
          path: .

      - name: Scan all repositories
        env:
          GITHUB_ORGS: ${{ inputs.github-orgs || github.event.inputs.github-orgs || github.repository_owner }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_APP_TOKEN: ${{ env.GITHUB_APP_TOKEN }}
          GITHUB_APP_TOKEN_MAP: ${{ needs.get-repos.outputs.token-map }}
          GITHUB_WORKSPACE: ${{ github.workspace }}
          MAX_RETRIES: ${{ env.MAX_RETRIES }}
        run: |
          docker run --rm \
            --user $(id -u):$(id -g) \
            -v "${{ github.workspace }}":/workspace \
            -w /workspace \
            -e GITHUB_ORGS \
            -e GITHUB_REPOSITORY \
            -e GITHUB_APP_TOKEN \
            -e GITHUB_APP_TOKEN_MAP \
            -e GITHUB_WORKSPACE=/workspace \
            -e MAX_RETRIES \
            ghcr.io/${{ github.repository_owner }}/sparta:latest \
            scan-repos

      - name: Upload scan results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: scan-results-no-batch
          path: |
            vulnerability-reports/
            scan-state-*.json
          retention-days: 7
          if-no-files-found: ignore

  commit-results:
    name: Commit Scan Results
    needs: [get-repos, scan-batches, scan-no-batch]
    runs-on: ubuntu-latest
    if: always()
    permissions:
      contents: write
      pull-requests: read
      packages: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Generate GitHub App token
        id: generate-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.SPARTA_APP_ID }}
          private-key: ${{ secrets.SPARTA_APP_PRIVATE_KEY }}
          owner: ${{ github.repository_owner }}

      - name: Mask token and set environment
        id: mask-token
        env:
          GENERATED_TOKEN: ${{ steps.generate-token.outputs.token }}
        run: |
          if [ -z "$GENERATED_TOKEN" ]; then
            echo "GitHub App token generation failed" >&2
            exit 1
          fi
          echo "::add-mask::$GENERATED_TOKEN"
          echo "GITHUB_APP_TOKEN=$GENERATED_TOKEN" >> $GITHUB_ENV

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Download all scan results
        uses: actions/download-artifact@v4
        with:
          pattern: scan-results-*
          merge-multiple: true
          path: .
          if-no-files-found: ignore
      
      - name: Download no-batch scan results
        uses: actions/download-artifact@v4
        if: always()
        with:
          name: scan-results-no-batch
          path: .
          if-no-files-found: ignore

      - name: Commit scan results and state files
        env:
          GITHUB_APP_TOKEN: ${{ env.GITHUB_APP_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          # Commit state files along with scan results
          docker run --rm \
            --user $(id -u):$(id -g) \
            -v "${{ github.workspace }}":/workspace \
            -w /workspace \
            -e GITHUB_APP_TOKEN \
            -e GITHUB_REPOSITORY \
            ghcr.io/${{ github.repository_owner }}/sparta:latest \
            commit-results
          
          # Also commit state files if they exist
          if [ -f scan-state-*.json ]; then
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git add scan-state-*.json || true
            git commit -m "Update scan state files" || true
            git push origin main || true
          fi

      - name: Workflow Summary
        if: always()
        run: |
          echo "## Multi-Organization Scan Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Total Organizations**: ${{ needs.get-repos.outputs.total-orgs }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Total Repositories**: ${{ needs.get-repos.outputs.total-repos }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Total Batches**: ${{ needs.get-repos.outputs.total-batches }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Batch Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Batch ID | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|--------|" >> $GITHUB_STEP_SUMMARY
          ${{ join(needs.scan-batches.*.result, '') }}
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Scan results have been committed to the repository." >> $GITHUB_STEP_SUMMARY

